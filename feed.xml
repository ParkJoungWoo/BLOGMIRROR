<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="https://parkjoungwoo.github.io/jekyll-theme-yat/feed.xml" rel="self" type="application/atom+xml" /><link href="https://parkjoungwoo.github.io/jekyll-theme-yat/" rel="alternate" type="text/html" /><updated>2022-12-19T07:57:36+00:00</updated><id>https://parkjoungwoo.github.io/jekyll-theme-yat/feed.xml</id><title type="html">정우의 블로그</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>박정우</name></author><entry><title type="html">Spring JPA 3일차</title><link href="https://parkjoungwoo.github.io/jekyll-theme-yat/spring/2022/12/14/springjpa3.html" rel="alternate" type="text/html" title="Spring JPA 3일차" /><published>2022-12-14T00:00:00+00:00</published><updated>2022-12-14T00:00:00+00:00</updated><id>https://parkjoungwoo.github.io/jekyll-theme-yat/spring/2022/12/14/springjpa3</id><content type="html" xml:base="https://parkjoungwoo.github.io/jekyll-theme-yat/spring/2022/12/14/springjpa3.html"><![CDATA[<h1 id="jpa-3일차--영속성-관리">JPA 3일차 : 영속성 관리</h1>

<h2 id="영속성-컨텍스트">영속성 컨텍스트</h2>
<p>JPA에서 가장 중요한것</p>
<ul>
  <li>객체와 RDB의 Mapping</li>
  <li>실제 동작(영속성 컨텍스트)</li>
</ul>

<p>엔티티 매니저 팩토리와 엔티티 매니저</p>

<p>웹 어플리케이션에서 EntityManagerFactory에서 EntityManager를 만들고<br />
EntityManager는 커넥션 풀을 통해 DB에 접근한다.</p>

<p>영속성 컨텍스트는 엔티티를 영구 저장하는 환경이라는 뜻(DB에 저장하기로 알고 있는 부분)</p>

<p>영속성 컨텍스트는 논리적인 개념이고 엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다.</p>

<h3 id="엔티티의-생명-주기">엔티티의 생명 주기</h3>
<ul>
  <li>비영속 : 영속성 컨텍스트와 전형 관계가 없는 새로운 상태</li>
  <li>영속 : 영속성 컨텍스트에 관리되는 상태</li>
  <li>준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태</li>
  <li>삭제 : 삭제된 상태</li>
</ul>

<p>그냥 객체만 만들면 -&gt; 비영속<br />
Entity Manager에서 persist를 수행하는 순간 -&gt; 영속 상태(query가 날라가지 않음)</p>

<p><code class="language-plaintext highlighter-rouge">EntityTransaction.commit()</code>이 이루어져야 query가 날라간다.</p>

<p>영속성 컨텍스트의 이점</p>
<ol>
  <li>1차캐시</li>
  <li>동일성 보장</li>
  <li>트랜잭션을 지원하는 쓰기 지연</li>
  <li>변경 감지</li>
  <li>지연 로딩</li>
</ol>

<p>영속성 컨텍스트는 내부에 1차 캐시를 가지고 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">object</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="n">object</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>

<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">object</span><span class="o">);</span>

<span class="nc">Object</span> <span class="n">findObject</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Object</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">차</span> <span class="n">캐시에서</span> <span class="n">조회한다</span><span class="o">.</span>

<span class="nc">Object</span> <span class="n">findObject2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Object</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">11</span><span class="o">);</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">차</span> <span class="n">캐시에</span> <span class="n">존재하지</span> <span class="n">않는다</span>
<span class="err">➡️</span><span class="n">이러한</span> <span class="n">경우는</span> <span class="mi">1</span><span class="o">)</span><span class="nc">DB에서</span> <span class="n">조회를</span> <span class="n">하고</span> <span class="mi">2</span><span class="o">)</span><span class="mi">1</span><span class="n">차</span> <span class="n">캐시에</span> <span class="n">저장을</span> <span class="n">하고</span> <span class="mi">3</span><span class="o">)</span> <span class="n">반환한다</span><span class="o">.</span>
<span class="o">(</span><span class="mi">1</span><span class="n">차</span> <span class="n">캐시는</span> <span class="n">성능</span> <span class="n">측면에서</span> <span class="n">높은</span> <span class="n">효과가</span> <span class="n">있지는</span> <span class="n">않다</span><span class="o">(</span><span class="n">트랜잭션</span> <span class="n">내에서만</span> <span class="n">쓰이는</span> <span class="mi">1</span><span class="n">차캐시이고</span> 
<span class="n">전체가</span> <span class="n">공유하는</span> <span class="mi">2</span><span class="n">차</span> <span class="n">캐시가</span> <span class="n">아니기</span> <span class="n">때문</span><span class="o">))</span>

<span class="n">또한</span> 
<span class="n">findObject</span> <span class="o">==</span> <span class="n">findObject2</span> <span class="n">이므로</span> <span class="n">영속</span> <span class="n">엔티티의</span> <span class="n">동일성을</span> <span class="n">보장한다</span><span class="o">.</span>
</code></pre></div></div>
<h3 id="쓰기-지연">쓰기 지연</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">findObject</span><span class="o">);</span><span class="n">를</span> <span class="n">한다고</span> <span class="n">바로</span> <span class="nc">DB에</span> <span class="nc">INSERT되는</span> <span class="n">것이</span> <span class="n">아니다</span><span class="o">.</span>
<span class="n">hibernate의</span> <span class="n">batch_size의</span> <span class="n">옵션을</span> <span class="n">기준으로</span> <span class="n">batch_size만큼의</span> <span class="n">개수가</span> <span class="n">쌓이면</span> <span class="n">한꺼번에</span> <span class="n">전송한다</span><span class="o">.</span>
</code></pre></div></div>
<p>커밋하는 순간(tx.commit)에 Query를 전송한다.</p>

<p>만약 find로 가져오고 그 객체를 수정한 상황이라고 가정해보자.</p>
<blockquote>
  <p>em.persist(찾은 객체)를 해야만 수정이 될까 -&gt; NO 오히려 좋지 않다.</p>
  <blockquote>
    <p>이 상황만으로도 update query가 전송된다.</p>
  </blockquote>
</blockquote>

<p>JPA는 Dirty Check(변경 감지)</p>

<p>1차 캐시에는 ID와 Entity와 스냅샷을 가지고 있다.(스냅샷이 가장 처음 가져온 엔티티)</p>

<p>(flush)만약 Entity와 스냅샷이 다를 경우 UPDATE query를 전송한다.(remove도 똑같은 방법으로 진행된다.)</p>

<p>⭐⭐⭐⭐결국은 tx.commit()의 시점에 데이터 변경이 된다고 알자.</p>

<h3 id="flush">FLUSH</h3>

<p>플러시 : 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영</p>

<p>플러시가 발생하는 조건 :</p>
<ol>
  <li>변경 감지(Dirty Check)</li>
  <li>수정된 엔티티 쓰기 지연</li>
  <li>쓰기 지연 SQL 저장소 Query를 데이터베이스에 전송(등록,수정,삭제)</li>
</ol>

<p>방법 :</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>em.flush()
tx.commit() -&gt; 자동으로 호출
JPQL query 실행 -&gt; 자동으로 호출
</code></pre></div></div>
<p>if -&gt; commit보다 flush가 먼저 일어나면?</p>
<blockquote>
  <p>query가 먼저 실행된다.</p>
</blockquote>

<p>flush 옵션</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>em.setFlushMode(FlushModeType.COMMIT)
FlushModeType.AUTO -&gt; 기본값(커밋, 쿼리 실행시 플러시)
FlushModeType.COMMIT -&gt; 커밋할 때만 플러시
</code></pre></div></div>

<h3 id="준영속-상태">준영속 상태</h3>
<p>영속 -&gt; 준영속</p>

<p>영속 상태 -&gt; 1차 캐시에 데이터가 올라가 JPA가 관리하는 상황을 뜻함</p>

<p>준영속 상태 -&gt; 영속성 컨텍스트의 이점을 받지 못하는 상황</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">em</span><span class="o">.</span><span class="na">detach</span><span class="o">(</span><span class="n">entity</span><span class="o">);</span> <span class="n">특정</span> <span class="n">엔티티만</span> <span class="n">준영속</span> <span class="n">상태로</span><span class="o">(</span><span class="nc">Update</span><span class="o">,</span> <span class="n">delete</span> <span class="n">등</span> <span class="n">관리</span> <span class="no">X</span><span class="o">)</span>
<span class="n">em</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span> <span class="n">영속성</span> <span class="n">컨텍스트를</span> <span class="n">완전히</span> <span class="n">초기화</span>
<span class="n">em</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="n">영속성</span> <span class="n">컨텍스트를</span> <span class="n">종료</span>
</code></pre></div></div>]]></content><author><name>박정우</name></author><category term="spring" /><category term="spring" /><summary type="html"><![CDATA[JPA 3일차 : 영속성 관리]]></summary></entry><entry><title type="html">Spring JPA 2일차</title><link href="https://parkjoungwoo.github.io/jekyll-theme-yat/spring/2022/12/12/springjpa2.html" rel="alternate" type="text/html" title="Spring JPA 2일차" /><published>2022-12-12T00:00:00+00:00</published><updated>2022-12-12T00:00:00+00:00</updated><id>https://parkjoungwoo.github.io/jekyll-theme-yat/spring/2022/12/12/springjpa2</id><content type="html" xml:base="https://parkjoungwoo.github.io/jekyll-theme-yat/spring/2022/12/12/springjpa2.html"><![CDATA[<h1 id="jpa-2일차--jpa-시작">JPA 2일차 : JPA 시작</h1>

<h2 id="maven-pom-구성">Maven pom 구성</h2>
<p>hibernate-entitymanager : hibernate의 필요한 의존성 라이브러리를 가져온다, 그 중에서 가장 중요한 것은 hibernate-core</p>

<p>hibernate를 사용? -&gt; JPA 구현체를 hibernate로 선택</p>

<h2 id="데이터베이스간의-차이점">데이터베이스간의 차이점</h2>
<p>JPA는 특정 데이터베이스에 종속하지 않는다.</p>

<p>각각의 데이터베이스가 제공하는 SQL 문법과 함수는 조금씩 다르다.(ex. MySQL, Oracle)</p>

<p>hibernate에서는 이를 dialect(방언)이라고 정의한다.</p>

<h2 id="jpa-구동-방식">JPA 구동 방식</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Persistence - 2.생성 -&gt; EntityManagerFactory
    |                           |
1.설정 정보 조회               3. 생성
    |                           |
META-INF/                   EntityManger1,2,3.. 
persistence.xml
</code></pre></div></div>
<p>코드를 보고 차이점 확인하기</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">EntityManagerFactory</span> <span class="n">enf</span> <span class="o">=</span> <span class="nc">Persistence</span><span class="o">.</span><span class="na">createEntityManagerFactory</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
<span class="nc">EntityManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">enf</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>
<span class="c1">//code</span>
<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
<span class="n">member</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
<span class="n">member</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"HelloA"</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
<span class="c1">//</span>
<span class="n">em</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">enf</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">EntityManagerFactory</span> <span class="n">enf</span> <span class="o">=</span> <span class="nc">Persistence</span><span class="o">.</span><span class="na">createEntityManagerFactory</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
<span class="nc">EntityManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">enf</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>
<span class="nc">EntityTransaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>
<span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
<span class="c1">//code</span>
<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
<span class="n">member</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
<span class="n">member</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"HelloA"</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
<span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="c1">//</span>
<span class="n">em</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">enf</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div>
<p>트랜잭션이 JPA에서 중요하다. = 모든 JPA의 작업은 트랜잭션의 단위에서 실행되야한다.</p>

<p>==&gt; EntityManger에서 Transaction을 받아오고 commit()을 하는 이유.</p>

<h2 id="객체처럼-다루기">객체처럼 다루기</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
<span class="n">findMember</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"HelloJpa"</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">findMember</span><span class="o">);</span>
<span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
</code></pre></div></div>
<p>위에서 생성한 Id가 1인 객체를 setName으로 수정하면 그대로 데이터 베이스에 적용된다.</p>

<ul>
  <li>EntityManagerFactory는 WAS에서 서버가 올라올 시점에서 DB당 하나만 생성된다.(어플리케이션 전체에서 공유)</li>
  <li>EntityManager는 요청이 올때 생성되고 쓰레드간에 공유X (사용하고 버려야 한다.)</li>
  <li>JPA의 모든 데이터 변경은 트랜잭션 안에서 실행된다.</li>
</ul>

<p>JPA는 객체지향 Query이므로 DB에 맞게 실제 query가 수정된다. = JPQL이라는 객체 지향 쿼리 언어를 제공.</p>

<p>검색을 할때 엔티티 객체를 대상으로 검색한다.</p>
<ul>
  <li>JPQL은 엔티티 객체를 대상으로 쿼리.</li>
  <li>SQL은 데이터베이스 테이블을 대상으로 쿼리.</li>
</ul>]]></content><author><name>박정우</name></author><category term="spring" /><category term="spring" /><summary type="html"><![CDATA[JPA 2일차 : JPA 시작]]></summary></entry><entry><title type="html">Spring JPA 1일차</title><link href="https://parkjoungwoo.github.io/jekyll-theme-yat/spring/2022/12/11/springjpa1.html" rel="alternate" type="text/html" title="Spring JPA 1일차" /><published>2022-12-11T00:00:00+00:00</published><updated>2022-12-11T00:00:00+00:00</updated><id>https://parkjoungwoo.github.io/jekyll-theme-yat/spring/2022/12/11/springjpa1</id><content type="html" xml:base="https://parkjoungwoo.github.io/jekyll-theme-yat/spring/2022/12/11/springjpa1.html"><![CDATA[<h1 id="jpa-1일차--jpa-개요-알아보기">JPA 1일차 : JPA 개요 알아보기</h1>

<h2 id="jpa란">JPA란?</h2>
<p>과거에 객체를 데이터베이스에 저장 -&gt; Jdbc API, SQL을 작성해야 했다.</p>

<p>JdbcTemplate(SQL Mapper)의 등장으로 코드는 줄었지만 SQL은 작성해야 함.</p>

<p>JPA의 등장으로 SQL마저도 작성할 필요가 없어졌다.</p>

<ol>
  <li>객체와 테이블을 올바르게 매핑하는 방법이 어렵다.</li>
  <li>JPA의 내부 동작 방식을 이해해야한다.</li>
</ol>

<h2 id="객체와-관계형-데이터베이스">객체와 관계형 데이터베이스</h2>
<p>대부분의 자바 스프링 서버는 객체 지향 프로그래밍을 수행한다.</p>

<p>그렇다면 객체는 어디에 저장되어야 하는가?
RDB, NoSQL, File, OODB… 여러가지 방안이 있지만 현실적인 방안은 RDB이다.</p>

<ul>
  <li>객체와 관계형 데이터베이스의 차이
    <ol>
      <li>상속</li>
    </ol>
    <ul>
      <li>객체는 상속관계가 존재하는 반면 데이터베이스는 슈퍼타입, 서브타입 관계가 존재.</li>
      <li>RDB에는 상속관계를 저장할 수 없음
        <ol>
          <li>연관관계</li>
        </ol>
      </li>
      <li>객체는 참조를 사용</li>
      <li>테이블은 외래키를 사용한다.
        <ol>
          <li>데이터 타입</li>
        </ol>
      </li>
      <li>객체를 테이블에 맞춰 모델링(ex 공통키를 클래스에 모두 포함)</li>
      <li>이 모델링은 객체다운 모델링이 아니다(객체는 참조로 연관관계을 맺는다.)
        <ol>
          <li>데이터 식별 방법</li>
        </ol>
      </li>
      <li>위와같은 방법이면 사람 id 조회, 그 결과로 팀 id 조회, 여러번 순차적으로 수행해야한다.</li>
    </ul>
  </li>
</ul>

<h2 id="객체-그래프-탐색">객체 그래프 탐색</h2>
<p>객체는 자유롭게 객체 그래프를 탐색할 수 있어야 한다.</p>

<p>클래스에 포함된 객체를 자유롭게 탐색할 수 있어야 한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ex) 사람 객체의 학교 객체, 학교 객체에서 다른 학생의 객체 ...
하지만 SQL에 따라서 탐색 범위가 결정된다.

많은 데이터를 조회 -&gt; 다른 객체 구성 가능 -&gt; 다른 객체 조회 가능
적은 데이터 조회 -&gt; 다른 데이터 구성 불가능 -&gt; 다른 객체 조회 불가능
</code></pre></div></div>
<p>객체답게 모델링 할수록 매핑 작업만 일어난다.</p>

<blockquote>
  <p>⭐객체를 자바 컬렉션에 저장 하듯이 DB에 저장할 수 없을까? -&gt; JPA</p>
</blockquote>

<h2 id="jpa-orm">JPA, ORM</h2>
<p>JPA 는 java ORM의 표준이다. -&gt; ORM은 ??</p>
<blockquote>
  <p>ORM : 객체 관계 매핑</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>객체는 객체대로 설계
관계형 DB는 관계형 DB대로 설계
매핑은 ORM이 대신 해준다.
</code></pre></div>  </div>
  <p>JPA는 애플리케이션과 JDBC 사이에서 동작<br />
Entity를 분석하고 SQL을 생성한다(JDBC API이용), 위에서 언급하나 <code class="language-plaintext highlighter-rouge">패러다임 불일치 해결</code><br />
JPA는 <code class="language-plaintext highlighter-rouge">인터페이스 모음</code>이다.</p>
</blockquote>

<p>JPA -&gt; 객체지향 개발이 가능하다, 데이터 접근 추상화와 벤더 독립성이 있다.</p>

<p>JPA와 패러다임의 불일치 해결</p>
<ol>
  <li>JPA와 상속</li>
  <li>JPA와 연관관계</li>
  <li>JPA와 객체 그래프 탐색</li>
  <li>JPA와 비교하기</li>
</ol>

<p>동일한 트랜잭션에 대해서 일치성 보장</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="n">jpa</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>
<span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="n">jpa</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>
<span class="n">member1</span> <span class="o">==</span> <span class="n">member2</span>
</code></pre></div></div>
<ul>
  <li>같은 트랜잭션 안에서는 같은 엔티티를 반환한다.(조회 성능 향상)</li>
  <li>DB Isolation Level이 read commit이어도 Repeatable Read를 보장한다.</li>
</ul>

<p>JPA 성능 최적화 기능</p>
<ol>
  <li>1차 캐시와 동일성 보장</li>
  <li>트랜잭션을 지원하는 쓰기 지연</li>
  <li>지연 로딩</li>
</ol>]]></content><author><name>박정우</name></author><category term="spring" /><category term="spring" /><summary type="html"><![CDATA[JPA 1일차 : JPA 개요 알아보기]]></summary></entry><entry><title type="html">CS 공부 정리</title><link href="https://parkjoungwoo.github.io/jekyll-theme-yat/cs/2022/12/04/csTest.html" rel="alternate" type="text/html" title="CS 공부 정리" /><published>2022-12-04T00:00:00+00:00</published><updated>2022-12-04T00:00:00+00:00</updated><id>https://parkjoungwoo.github.io/jekyll-theme-yat/cs/2022/12/04/csTest</id><content type="html" xml:base="https://parkjoungwoo.github.io/jekyll-theme-yat/cs/2022/12/04/csTest.html"><![CDATA[<h1 id="현대-cs-테스트-준비를-위한-문서입니다">현대 CS 테스트 준비를 위한 문서입니다.</h1>

<h2 id="운영체제">운영체제</h2>
<h3 id="스레드">스레드</h3>
<p>프로세스 : 프로그램 + 프로세스 제어 블록(PCB)</p>

<p>운영체제는 프로그램을 메모리에 가져오고 PCB를 작성.</p>

<p>프로세스의 진행 과정</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>new -&gt; ready -&gt; running -&gt; waiting -&gt; exit
</code></pre></div></div>
<p>프로세스의 구조</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Code 프로그램 명령이 위치하는 곳
Data 전역 변수나 static 변수 할당을 위해 존재
Stack 지역 변수, 인자 값 저장 위한 공간
Heap Java new를 통한 동적 할당을 위한 공간
</code></pre></div></div>
<p>스레드 : 프로세스가 생성되면 CPU 스케줄러는 프로세스가 해야 할 일을 CPU에 전달하고 CPU가 실제 작업을 수행한다.(CPU 스케줄러가 CPU에 전달하는 일 하나가 스레드이다.)</p>

<p>OS입장에서 작업 단위는 프로세스, CPU입장에서 작업 단위는 스레드이다.</p>

<p>스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap영역은 공유한다.</p>

<p><code class="language-plaintext highlighter-rouge">Java Thread</code> : JVM이 운영체제 역할을 한다.<br />
자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블럭이다.</p>
<blockquote>
  <p>main() 메소드가 수행되면서 하나의 스레드가 실행된다.</p>
</blockquote>

<p>스레드 : 하나의 작업을 동시에 수행하려면 여러 개의 프로세스를 실행해야하고 각각 메모리를 할당해야한다. 그에 반해 스레드는 낮은 메모리를 할당.</p>

<p>자바 메모리 관리 : <code class="language-plaintext highlighter-rouge">STACK, HEAP</code></p>

<p>자바의 메모리는 Stack, Heap영역으로 구분.
Stack 영역</p>
<ul>
  <li>Heap에서 생성된 객체의 주소를 저장</li>
  <li>기본 타입의 실제 값을 저장</li>
  <li>각 지역 변수들은 scope에 맞는 Stack 영역을 가진다.</li>
  <li>Thread는 각자 Stack을 가진다.
    <h3 id="페이지-테이블-할당-방법">페이지 테이블 할당 방법</h3>
    <h3 id="lru">LRU</h3>
    <p>가장 오랫동안 참조되지 않은 페이지를 교체하는 기법.<br />
페이지 교체 알고리즘 예시 : FIFO, LFU, LRU 기법이 있다.</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FIFO -&gt; 적재된 시간을 기준으로 교체 페이지 선정
  최근에 들어온 페이지를 우선 교체
  먼저 들어온 페이지가 오래 상주하는 문제 발생
LFU -&gt; 가장 적은 횟수를 참조하는 페이지 교체
  교체대상이 여러개면 가장 오래 사용하지 않은 페이지를 교체
LRU -&gt; 가장 오랫동안 참조되지 않은 페이지 교체
  참조되면 top으로 이동
OPT -&gt; 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체
  (구현이 불가능)
MFU -&gt; 참조 횟수가 가장 많은 페이지를 교체
</code></pre></div>    </div>
    <h3 id="rr">RR</h3>
    <p>RR -&gt; 시분할 시스템을 위해 설계된 선점형 스케줄링<br />
프로세스들의 우선순위를 두지 않고 시간단위로 CPU를 할당하는 방식의 CPU 스케줄링 알고리즘.</p>
  </li>
</ul>

<p>프로세스 스케줄링 : CPU를 사용하려고 하는 프로세스들 사이의 우선순위를 관리하는 일.</p>

<p>디스크 스케줄링 : 디스크를 사용하려고 하는 프로세스들 사이의 우선순위를 관리하는 일.</p>

<p>스케줄링 -(처리율, CPU 이용율을 증가/오버헤드/응답시간/반환시간/대기시간을 최소화하기 위한 기법)</p>

<ul>
  <li>비선점/ 선점 스케줄링
    <ul>
      <li>비선점 스케줄링 : 프로세스가 (실행-대기),(실행-종료)의 상태전이가 있을 때 적용</li>
      <li>선점 스케줄링 : (실행-대기),(실행-준비),(대기-준비),(수행-종료) 모든 상태 변화에서 적용</li>
    </ul>
  </li>
</ul>

<p>비선점 - 이미 할당된 CPU를 다른 프로세스가 강제로 뺏을 수 없다.</p>

<ul>
  <li>FIFO : 선입선출</li>
  <li>SJF : 점유율이 짧은 프로세스에 CPU 먼저 할당</li>
  <li>HRN : 대기시간, 서비스시간 이용
    <ul>
      <li>HRN 공식 : 우선순위 = (대기시간 + 서비스 시간)/서비스 시간 = 높은 것 부터</li>
    </ul>
  </li>
</ul>

<p>선점 - 하나의 프로세스가 CPU를 할당 받아 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있다.(시분할에 적합)</p>
<ul>
  <li>SRT : SJF을 선점 형태로 변경한 기법 CPU 시간이 짧은 프로세스에 CPU를 먼저 할당.</li>
  <li>RR : 프로세스 사이에 우선순위를 두지 않고 순서대로 시간단위로 CPU를 할당</li>
  <li>MQ : 다단계 큐, 프로세스를 특정 그룹으로 분류할 수 있을 때 그룹에 따라 다른 준비 상태 큐를 사용하는 기법.
    <h3 id="데드락">데드락</h3>
    <blockquote>
      <p>두개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해 다음 처리를 하지 못하는 상태</p>
    </blockquote>
  </li>
</ul>

<p>무한히 다음 자원을 기다리는 상황.</p>
<blockquote>
  <p>데드락 발생 조건</p>
  <ol>
    <li>상호 배제
      <ul>
        <li>자원은 한번에 한 프로세스만 사용할 수 있다.</li>
      </ul>
    </li>
    <li>점유 대기
      <ul>
        <li>최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야함.</li>
      </ul>
    </li>
    <li>비선점
      <ul>
        <li>다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없다.</li>
      </ul>
    </li>
    <li>순환 대기
      <ul>
        <li>프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다.</li>
      </ul>
    </li>
  </ol>
</blockquote>

<p>교착상태(데드락) 예방 &amp; 회피 방법</p>
<ol>
  <li>예방
    <ul>
      <li>교착 상태 발생 조건중 하나를 제거하면서 해결</li>
    </ul>
  </li>
  <li>회피
    <ul>
      <li>은행원 알고리즘
        <ul>
          <li>프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사=교착 상태 회피</li>
          <li>안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 기다리기.
            <h2 id="네트워크">네트워크</h2>
            <h3 id="tcpip-개념">TCP/IP 개념</h3>
            <p>컴퓨터와 네트워크기기 간 통신을 하기 위해서는 서로 같은 방법으로 통신해야한다.<br />
-&gt; 이를 프로토콜이라고 한다.<br />
TCP/IP는 인터넷과 관련된 프로콜을 의미.</p>
            <blockquote>
              <p>TCP/IP : 애플리케이션 - 트랜스포트 - 네트워크 - 링크 4계층으로 구성되어 있다.</p>
            </blockquote>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p>애플리케이션 계층 : 유저에게 제공되는 통신의 움직임(HTTP)<br />
트랜스포트 계층 : 컴퓨터 사이의 데이터 흐름을 제공(TCP/UDP)<br />
네트워크 계층 : 네트워크 상에서 패킷의 이동을 다루는 계층, 패킷은 전송하는 데이터의 최소 단위.<br />
링크 계층 : 네트워크에 접속하는 하드웨어적인 면을 다룬다.</p>

<p>애플리케이션 계층에서 하위 계층으로 가면서 해당 계층의 정보를 헤더에 추가하는 과정 = 캡슐화<br />
하위 계층에서 애플리케이션 계층으로 가면서 헤더의 정보를 제거하는 과정 = 역캡슐화</p>

<h3 id="ip-프로토콜-개념">IP 프로토콜 개념</h3>
<p>IP는 Internet Protocol의 약자이다 + 네트워크 층에 해당한다.<br />
IP의 역할은 개개의 패킷을 상대방에게 전달…<br />
전달하기 위해서 (IP주소와 MAC주소가 중요)<br />
IP 주소는 각 노드에 부여된 주소를 가리키고 MAC 주소는 각 네트워크 카드에 할당되 고유의 주소이다. IP는 변경가능하지만 MAC 주소는 변경할 수 없다.</p>

<p>통신은 ARP(Address Resolution Protocol)이라는 프로토콜이 사용된다.<br />
IP 통신은 MAC 주소에 의존해서 통신한다. 인터넷에서 통신 상대가 같은 랜선 내에 있을 확률은 매우 낮고 여러 컴퓨터, 네트워크 기기를 중계해 상대방에게 도착한다.<br />
이때 ARP 프로토콜이 사용된다. ARP는 주소를 해결하기 위한 프로토콜, 수신지의 IP 주소를 바탕으로 MAC 주소를 조사할 수 있다.</p>
<h3 id="브로드-캐스트">브로드 캐스트</h3>
<p>유니 캐스팅 : 하나의 송신자가 다른 하나의 송신자에게 데이터를 전송하는 방식.(MAC 주소를 기반으로 상대측 IP 주소를 목적지로 하는 1대1 통신방식)<br />
-&gt; 유니 캐스팅은 네트워크 효율이 저하된다.</p>

<p>브로드 캐스팅 : 송신 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에 전송되는 방식.<br />
로컬에 붙어있는 모든 네트워크 장비에 의사와 상관 없이 모두 보내는 방식.<br />
브로드 캐스팅 주소는 미리 정해져 있다 : FF:FF:FF:FF:FF:FF<br />
데이터를 수신할 필요가 없는 호스트들에게도 데이터가 전송.. 불필요한 인터럽트가 발생</p>

<p>멀티 캐스팅 : UDP를 기반으로 특정한 하나 이상의 수신자들에게 데이터를 전송하는 방식.(멀티 캐스팅 전송을 위한 특별한 그룹 주소를 사용하기 때문 D 클래스 주소 IP)</p>

<h3 id="서브넷-마스크">서브넷 마스크</h3>
<p>서브넷 : 네트워크를 분할함</p>

<p>A 클래스의 대규모 네트워크를 작은 네트워크로 분할하면 브로드캐스트로 전송되는 패킷의 범위를 좁힐 수 있다.<br />
네트워크를 분할하기 -&gt; subneting(서브네팅)<br />
분할 한 네트워크 -&gt; subnet(서브넷)</p>

<p>서브네팅을 할 경우 어디까지가 네트워크 ID이고 어디가 호스트 ID인지 판단하기 어려움.. -&gt; 서브넷 마스크 값을 활용</p>

<p>서브넷 마스크는 네트워크 ID와 호스트 ID를 식별하기 위한 값.<br />
서브네팅이 되면 네트워크 ID + 호스트 ID 에서</p>
<blockquote>
  <p>네트워크 ID + 서브넷 ID + 호스트 ID로 변경된다.</p>
</blockquote>

<ol>
  <li>IP 주소에는 반드시 서브넷 마스크가 있다.</li>
  <li>서브넷 마스크는 기본적으로 255와 0으로 이루어져 있다.</li>
  <li>255는 네트워크 부분, 0은 호스트 부분이다.</li>
  <li>255로 된 부분은 무시하고 0으로 된 부분에서 IP를 나눠쓰는 혹은 IP를 쪼갠다.</li>
</ol>

<p>IP를 쪼개는 이유 -&gt; IP주소가 모자라기 때문</p>
<blockquote>
  <p>서브넷 마스크의 형태는 IP 주소와 똑같이 32비트 2진수(IP 주소와 AND 연산하기 위해서이다.)</p>
</blockquote>

<p>서브넷 마스크를 사용하는 이유 : 브로드캐스트 영역(네트워크)를 나누기 위함이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>192.168.0.3/24
IP주소 : 192.168.0.3
서브넷 마스크 : 255.255.255.0

192.168.0.3/25
IP주소 : 192.168.0.3
서브넷 마스크 : 255.255.255.128

C클래스 네트워크를 26개의 서브넷으로 나누기
255.255.255.
00000000
VVVVV000 -&gt; 248 (2*2*2*2*2 &gt;= 26이므로)

A클래스 표준 네트워크 서브넷 클래스 
255.0.0.0
B클래스 표준 네트워크 서브넷 클래스 
255.255.0.0
.
.
.
</code></pre></div></div>
<h2 id="자료구조">자료구조</h2>
<h3 id="이진-트리">이진 트리</h3>
<p>트리 -&gt; 모양이 뒤집어 놓은 나무와 같다고 해서 작명됨.</p>

<p>순환되면 트리가 아니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>시작점 -&gt; root
끝 점 -&gt; leaves
root의 레벨 0
root 자식의 레벨 1
root 자식의 자식 레벨 2
.
.
.
</code></pre></div></div>
<p>이진트리(최대 두 개인 노드들로 구성된 트리) -&gt; 정이진트리, 완전이진트리, 균형이진트리 가 있다.</p>

<ul>
  <li>정이진트리 : 모든 레벨에서 노드들이 꽉 채워진 이진트리</li>
  <li>완전이진트리 : 마지막 레벨을 제외한 모든 레벨에서 노드들이 채워짐</li>
  <li>균형이진트리 : 모든 잎새노드의 깊이 차이가 1인 트리.</li>
</ul>

<p>트리 순회 순서 : preorder, inorder, postorder(루트의 위치에 따라)</p>

<h3 id="힙-구조">힙 구조</h3>
<p>힙 자료구조 == 완전 이진 트리를 기초로 하는 자료구조</p>

<p>마지막을 제외한 모든 노드에서 자식들이 꽉 채워진 이진트리를 의미한다.</p>

<p>힙은 최대힙과 최소힙으로 나눠진다.<br />
최대 힙 = 부모 노드의 값이 자식노드들의 값보다 항상 크고,</p>

<p>최소힙은 부모노드의 값이 자식노드의 값보다 항상 작다.</p>
<h3 id="맵">맵</h3>
<p>key와 value로 이루어진 자료구조</p>

<p>key의 중복을 허용하지 않는다. (값은 중복되어도 상관 X)</p>

<p>HashMap : key와 value의 쌍으로만 구성, 순서는 보장하지 않는다.</p>

<p>TreeMap : key의 값을 이용해 순서대로 정렬하여 데이터를 저장하는 자료구조</p>

<p>LinkedHashMap : 데이터를 입력한 순서대로 쌓아지며 데이터를 저장하는 자료구조</p>
<h2 id="알고리즘">알고리즘</h2>
<h3 id="다익스트라">다익스트라</h3>
<p>다익스트라 알고리즘 : 최단경로 탐색 알고리즘</p>

<p>최단 경로는 여러 개의 최단 경로로 이루어져있다 + 다이나믹 프로그래밍</p>

<h2 id="프로그래밍-일반">프로그래밍 일반</h2>
<h3 id="구조체-선언-크기">구조체 선언, 크기</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">student</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="err">크기</span> <span class="o">=</span> <span class="mi">12</span><span class="err">바이트</span>
<span class="err">ㅁㅁㅁㅁ</span><span class="o">/</span><span class="err">ㅁㅁㅁㅁ</span><span class="o">/</span><span class="err">ㅁㅁㅁㅁ</span>
<span class="kt">char</span><span class="o">/</span><span class="kt">int</span><span class="o">/</span><span class="kt">char</span>
<span class="kt">int</span> <span class="mi">4</span><span class="err">바이트</span>
<span class="kt">char</span> <span class="mi">1</span><span class="err">바이트</span><span class="p">(</span><span class="err">구조체</span> <span class="err">포함은</span> <span class="mi">4</span><span class="err">바이트</span><span class="p">)</span>
<span class="kt">double</span> <span class="mi">8</span><span class="err">바이트</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">student</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="err">ㅁㅁㅁㅁ</span><span class="o">/</span><span class="err">ㅁㅁㅁㅁ</span><span class="o">/</span><span class="err">ㅁㅁㅁㅁㅁㅁㅁㅁ</span>
<span class="kt">char</span><span class="o">/</span><span class="kt">int</span><span class="o">/</span><span class="kt">double</span>
<span class="err">크기</span> <span class="o">=</span> <span class="mi">16</span><span class="err">바이트</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">student</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
<span class="err">ㅁㅁㅁㅁㅁㅁㅁㅁ</span><span class="o">/</span><span class="err">ㅁㅁㅁㅁㅁㅁㅁㅁ</span><span class="o">/</span><span class="err">ㅁㅁㅁㅁㅁㅁㅁㅁ</span>
<span class="kt">char</span><span class="o">/</span><span class="kt">double</span><span class="o">/</span><span class="kt">int</span>

<span class="err">구조체는</span> <span class="err">가장</span> <span class="err">큰</span> <span class="err">자료형</span> <span class="o">*</span> <span class="n">n</span><span class="err">의</span> <span class="err">배수로</span> <span class="err">이루어져</span> <span class="err">있다</span><span class="p">.</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">student</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">ee</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">eee</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">e</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">g</span><span class="p">;</span>
<span class="p">}</span><span class="n">ss</span><span class="p">;</span>
<span class="err">크기</span> <span class="o">=</span> <span class="mi">16</span><span class="err">바이트</span>
</code></pre></div></div>
<h2 id="데이터베이스">데이터베이스</h2>
<h3 id="데이터-베이스-설계">데이터 베이스 설계</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>요구분석
개념적 설계 : 개념 스키마, 트랜잭션 모델링, E-R 모델
정보 모델링, 개념화
논리적 설계 : 목표 DBMS에 맞는 스키마 설계(관계형 데이터 베이스에서 테이블을 설계하는 단계)
물리적 설계 : 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터 베이스로 변환(반응시간, 공간활용도, 트랜잭션 처리량 고려)
구현
</code></pre></div></div>
<ul>
  <li>도메인 : 원자값들의 집합</li>
  <li>속성 : 릴레이션을 구성하는 각각의 열, 속성 수 = 차수</li>
  <li>튜플 : 릴레이션을 구성하는 각가의 행</li>
  <li>후보키 : 식별하기 위해 사용되는 속성들의 부분 집합</li>
  <li>기본키 : 후보키 중 선택한 주키</li>
  <li>대체키 : 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키(보조키)</li>
  <li>슈퍼키 : 유일성은 만족하지만 최소성을 만족하지 않는 키</li>
  <li>외래키 : 다른 테이블의 기본키를 가져온 것.
    <h3 id="isolation-level">Isolation Level</h3>
    <p>동시에 여러 트랜잭션이 처리될 때</p>
  </li>
  <li>특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있을지 결정하는 것.
    <ol>
      <li>READ UNCOMMITTED</li>
    </ol>
    <ul>
      <li>각 트랜잭션에서의 변경 내용이 commit이나 rollback 여부에 상관 없이 다른 트랜잭션에서 값을 읽을 수 있다.</li>
      <li>정합성에 문제가 많은 격리 수준이기 때문에 사용하는 것을 권장하지 않는다.</li>
      <li><code class="language-plaintext highlighter-rouge">dirty read</code>현상이 발생한다.
        <ol>
          <li>READ COMMITTED</li>
        </ol>
      </li>
      <li>대부분의 격리 수준.</li>
      <li><code class="language-plaintext highlighter-rouge">dirty read</code>현상은 나타나지 않는다.</li>
      <li>실제 테이블 값을 가져오는 것이 아닌 <code class="language-plaintext highlighter-rouge">undo 영역</code>에 <code class="language-plaintext highlighter-rouge">백업된 레코드</code>에서 값을 가져온다.</li>
      <li>하지만 똑같은 SELECT를 실행했을 때 항상 같은 결과가 나타남을 보장하지 않는다.
        <ol>
          <li>REPEATABLE READ</li>
        </ol>
      </li>
      <li>읽을 때마다 같은 값을 받아와야 한다.</li>
      <li>Undo 공간에 백업해두고 실제 레코드 값을 변경한다.</li>
      <li>백업된 데이터는 불필요하다고 판단되면 주기적으로 삭제한다.</li>
      <li><code class="language-plaintext highlighter-rouge">PHANTOM READ</code> 다른 트랜잭션에 의해 레코드가 보였다 안보였다하는 현상(쓰기 잠금을 걸어야 한다.)
        <ol>
          <li>SERIALIZABLE</li>
        </ol>
      </li>
      <li>가장 단순한 격리 수준이지만 가장 엄격한 격리 수준</li>
      <li>성능 측면에서 동시 처리 성능이 가장 낮다.</li>
      <li><code class="language-plaintext highlighter-rouge">PHANTOM READ</code>가 발생하지 않지만 거의 사용되지 않는다.
        <h3 id="sql">SQL</h3>
        <h3 id="commit-rollback">commit, rollback</h3>
        <p>트랜잭션 : 데이터베이스의 논리적 연산단위.</p>
      </li>
    </ul>
  </li>
  <li>원자성 : All Or Nothing</li>
  <li>일관성 : 트랜잭션이 수행하기 전과 후 모두 내용에 문제가 있으면 안된다.</li>
  <li>고립성 : 트랜잭션이 수행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과 X</li>
  <li>지속성 : 한번 성공적으로 수행되면 데이터베이스 내용은 영구적으로 저장.</li>
</ul>

<p>commit -&gt;</p>
<ul>
  <li>데이터에 대한 변경 사항이 데이터 베이스에 반영</li>
  <li>모든 사용자는 결과를 볼 수 있다.</li>
  <li>행에 대한 잠금이 풀리고 다른 사용자들이 행을 조작할 수 있다.</li>
</ul>

<p>roll back -&gt;</p>
<ul>
  <li>데이터에 대한 변경 사항이 취소된다.</li>
  <li>이전 데이터는 다시 재저장된다.</li>
  <li>행에 대한 잠금이 풀리고 다른 사용자들이 행을 조작할 수 있다.
    <h2 id="컴퓨터-구조">컴퓨터 구조</h2>
  </li>
</ul>

<h2 id="전산기초">전산기초</h2>
<h3 id="부동-소수점">부동 소수점</h3>
<p>-314.625를 예시로..</p>

<p>부호비트 1
지수비트 8
가수 비트 23비트</p>

<p>-1이니까 부호비트 1</p>

<p>314.625를 이진수로 ..</p>
<blockquote>
  <p>100111010.101</p>
</blockquote>

<p>1.00111010101 x 2^8로 (왼쪽에 1만 남도록)</p>

<p>00111010101을 가수비트에 앞에서 부터 채워주기</p>

<p>8은 지수 비트에서 127(bias)를 더해서 넣기</p>
<h3 id="음수-표현법">음수 표현법</h3>
<p>1의 보수 변환 후 1 더해주기</p>]]></content><author><name>박정우</name></author><category term="cs" /><category term="cs" /><summary type="html"><![CDATA[현대 CS 테스트 준비를 위한 문서입니다.]]></summary></entry><entry><title type="html">Preparing Project 2</title><link href="https://parkjoungwoo.github.io/jekyll-theme-yat/project/2022/10/07/preproject.html" rel="alternate" type="text/html" title="Preparing Project 2" /><published>2022-10-07T00:00:00+00:00</published><updated>2022-10-07T00:00:00+00:00</updated><id>https://parkjoungwoo.github.io/jekyll-theme-yat/project/2022/10/07/preproject</id><content type="html" xml:base="https://parkjoungwoo.github.io/jekyll-theme-yat/project/2022/10/07/preproject.html"><![CDATA[<h2 id="migrations">Migrations</h2>
<p>Django가 model에 변화를 반영하는 방법.</p>

<ul>
  <li>makemigrations
    <ul>
      <li>model을 변경한 것에 기반한 마이그레이션 만들때</li>
    </ul>
  </li>
  <li>migrate
    <ul>
      <li>마이그레이션을 DB에 반영하기</li>
      <li>설계도를 실제 DB에 반영</li>
      <li>모델 변경 사항과 DB의 스키마가 동기화</li>
    </ul>
  </li>
  <li>sqlmigrate
    <ul>
      <li>마이그레이션 SQL 구문을 보기 위해 사용</li>
      <li>마이그레이션이 SQL문으로 어떻게 동작하는지 미리확인</li>
    </ul>
  </li>
  <li>showmigrations
    <ul>
      <li>프로젝트 전체 마이그레이션 상태 확인</li>
      <li>마이그레이션 파일 migrate 여부 확인
```bash
마이그레이션 만들기
python manage.py makemigrations</li>
    </ul>
  </li>
</ul>

<p>실제 DB에 반영
python manage.py migrate</p>

<p>마이그레이션 SQL 구문 확인하기
python manage.py sqlmigrate 앱이름 0001 -&gt; migration순서</p>

<p>프로젝트 전체 마이그레이션 상태 확인
python manage.py showmigrations</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>### migration 순서
model의 변경사항이 있다
1. models.py
2. python manage.py makemigrations
3. python manage.py migrate

```SQL
Article -&gt; 클래스명

article = Article()
article.title = 'first'
article.content = 'django'
Article.objects.all()

article.save() -&gt; 객체 저장

article.title ...'first'
article.content ... 'django'
article.created_at ... datetime.datetime(2019, 8, 21, 2 ...)
</code></pre></div></div>
<p>또는</p>
<pre><code class="language-SQL">article = Article(title='second', content='django!!')
article.save()

article.pk -&gt; 2 (django에서는 index가 pk)
article.title -&gt; second

Article.objects.create(title='third', content='django!!')
-&gt; article.save()를 건너뛰기
</code></pre>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Article</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">TextField</span><span class="p">()</span>
    <span class="n">created_at</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">DateTimeField</span><span class="p">(</span><span class="n">auto_now_add</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">updated_at</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">DateTimeField</span><span class="p">(</span><span class="n">auto_now</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">title</span>
<span class="n">__str__을</span> <span class="n">통해</span> <span class="n">object가</span> <span class="n">사람이</span> <span class="n">읽을</span> <span class="n">수</span> <span class="n">있는</span> <span class="n">문자열</span> <span class="n">반환</span>
</code></pre></div></div>]]></content><author><name>박정우</name></author><category term="project" /><category term="web" /><summary type="html"><![CDATA[Migrations Django가 model에 변화를 반영하는 방법.]]></summary></entry><entry><title type="html">SQL</title><link href="https://parkjoungwoo.github.io/jekyll-theme-yat/project/2022/10/06/SQL.html" rel="alternate" type="text/html" title="SQL" /><published>2022-10-06T00:00:00+00:00</published><updated>2022-10-06T00:00:00+00:00</updated><id>https://parkjoungwoo.github.io/jekyll-theme-yat/project/2022/10/06/SQL</id><content type="html" xml:base="https://parkjoungwoo.github.io/jekyll-theme-yat/project/2022/10/06/SQL.html"><![CDATA[<h2 id="sql">SQL</h2>

<h2 id="select">SELECT</h2>
<p>중복 없이 선택</p>
<pre><code class="language-SQL">SELECT DISTINCT Country FROM Customers;
</code></pre>
<p>별칭과 함께 선택</p>
<pre><code class="language-SQL">SELECT COUNT(DISTINCT Country) AS Data FROM Customers;
</code></pre>
<p>조건문</p>
<pre><code class="language-SQL">대소 비교
일치
SELECT * FROM Customer WHERE CustomerID = 1;
초과
SELECT * FROM Customer WHERE CustomerID &gt; 1;
미만
SELECT * FROM Customer WHERE CustomerID &lt; 1;
이상
SELECT * FROM Customer WHERE CustomerID &gt;= 1;
이하
SELECT * FROM Customer WHERE CustomerID &lt;= 1;
제외 1
SELECT * FROM Customer WHERE CustomerID &lt;&gt; 1;
제외 2
SELECT * FROM Customer WHERE NOT Customer = 1;
범위 - 숫자
SELECT * FROM Customer WHERE CustomerID BETWEEN 1 AND 5;
범위 - 글자
SELECT * FROM Customer WHERE CustomerName BETWEEN 'Carnarvon' AND 'Mozzarella';
SELECT * FROM Customer WHERE CustomerID NOT BETWEEN 1 AND 5;
범위 - 날짜
SELECT * FROM Customer WHERE OrderDate BETWEEN #07/01/1996 AND #07/31/1996;
와일드 카드 조건문
SELECT * FROM Customer WHERE CustomerName LIKE '%우';
와일드 카드 조건문 NOT
SELECT * FROM Customer WHERE CustomerName NOT LIKE '%우';
</code></pre>

<table>
  <thead>
    <tr>
      <th>와일드카드</th>
      <th>의미</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>‘%우’</td>
      <td>우로 끝나는</td>
    </tr>
    <tr>
      <td>‘우%’</td>
      <td>우로 시작하는</td>
    </tr>
    <tr>
      <td>‘%우%’</td>
      <td>우가 포함되는</td>
    </tr>
    <tr>
      <td>‘_정%’</td>
      <td>적어도 두글자/ 두번째 글자는 정</td>
    </tr>
    <tr>
      <td>‘박_%’</td>
      <td>적어도 두글자/ 첫번째 글자는 박</td>
    </tr>
    <tr>
      <td>‘박__%’</td>
      <td>적어도 세글자/ 첫번째 글자는 박</td>
    </tr>
    <tr>
      <td>‘박%우’</td>
      <td>적어도 두글자/ 첫번째는 박, 우로 끝나는</td>
    </tr>
    <tr>
      <td>‘박[정종]우’</td>
      <td>박정우 또는 박종우로 인식</td>
    </tr>
    <tr>
      <td>‘박[!정종]우’</td>
      <td>박정우 또는 박종우를 제외하고 인식</td>
    </tr>
    <tr>
      <td>‘박[a-z]우’</td>
      <td>박a우… 박z우 로 인식</td>
    </tr>
  </tbody>
</table>

<pre><code class="language-SQL">소속여부-지정
SELECT * FROM Customer WHERE CustomerID IN (1, 5, 7);
소속여부-검색결과에서
SELECT * FROM Customers WHERE CustomerID IN (SELECT CustomerID FROM Customers WHERE CustomerID &gt; 10);
'AND'연산자
SELECT * FROM Customer WHERE CustomerID = 1 AND CustomerName='정우';
'OR'연산자
SELECT * FROM Customer WHERE CustomerID = 1 OR CustomerName='정우';
()로 조건 묶기
SELECT * FROM Customer WHERE Country='Germany' AND (City='Berlin' OR City='Manchester')
'LIKE'+ORDER BY
SELECT * FROM Customer WHERE CustomerName LIKE '%우' ORDER BY City ASC;
'LIKE'+ORDER BY
SELECT * FROM Customer WHERE CustomerName LIKE '%우' ORDER BY City DESC;
다중 정렬
SELECT * FROM Customer ORDER BY Country, City;
다중 정렬 세부 기준
SELECT * FROM Customer ORDER BY Country ASC, City DESC;
NULL을 가진 레코드 찾기
SELECT * FROM Customer WHERE City IS NULL;
NULL을 가지지 않은 레코드 찾기
SELECT * FROM Customer WHERE City IS NOT NULL;

집계함수 사용
SELECT MIN(Price) AS SmallestPrice FROM Products;
SELECT MAX(Price) AS SmallestPrice FROM Products;
SELECT COUNT(Price) AS PRICE_COUNT FROM Products;
SELECT AVG(Price) AS AVG_PRICE FROM Products;
SELECT COUNT(Price) AS SUM_PRICE FROM Products;

Alias
여러 컬럼을 설정
SELECT CustomerID AS ID, CustomerName AS Customer FROM Customers;
띄어쓰기를 컬럼명으로 alias명으로 주고싶을 때
SELECT CustomerName AS Customer, ContactName AS [Contact Person] FROM Customers;
사용자 지정 양식으로 만들기
SELECT CustomerName, Address + ', ' + PostalCode + ' ' + City + ', ' + Country AS Address FROM Customers;
다른 테이블에 alias 적용하기
SELECT Orders.OrderID, Orders.OrderDate, Customers.CustomerName FROM Customers, Orders WHERE Customers.CustomerName='Around the Horn' AND Customers.CustomerID=Orders.

CustomerID; -&gt; 한번 테이블 명을 alias하면 쭉 alias명으로 사용해야한다.
SELECT o.OrderID, o.OrderDate, c.CustomerName FROM Customers AS c, Orders AS o WHERE c.CustomerName='Around the Horn' AND c.CustomerID=o.CustomerID;
</code></pre>
<h3 id="join">JOIN</h3>
<p>join 이해를 위한 사진</p>

<p><img src="/assets/img/1006/join.jpg" alt="img" /></p>

<p>w3 school에서 위와같은 참고사진을 받았다.</p>
<pre><code class="language-SQL">Oders와 Customers의 ID가 동일한 것 에서 ID와 CustomerName, OrderDate를 가져오기
SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate FROM Orders INNER JOIN Customers ON Orders.CustomerID=Customers.CustomerID;

삼중 조인
SELECT Orders.OrderID, Customers.CustomerName, Shippers.ShipperName
FROM ((Orders
INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID)
INNER JOIN Shippers ON Orders.ShipperID = Shippers.ShipperID);

SELECT Customers.CustomerName, Orders.OrderID FROM Customers FULL OUTER JOIN Orders ON Customers.CustomerID=Orders.CustomerID ORDER BY Customers.CustomerName;

LEFT JOIN 이면 왼쪽 테이블전체 + 오른쪽 테이블 공통부분
RIGHT JOIN 이면 오른쪽 테이블 전체 + 왼쪽 테이블 공통부분
INNER JOIN 이면 공통 부분
OUTER JOIN 이면 합집합

UNION을 통해 두 결과를 합하기
SELECT City FROM Customers UNION SELECT City FROM Suppliers ORDER BY City;
</code></pre>

<h2 id="insert">INSERT</h2>
<pre><code class="language-SQL">레코드 추가
INSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country)
VALUES ('Cardinal', 'Tom B. Erichsen', 'Skagen 21', 'Stavanger', '4006', 'Norway');
</code></pre>

<h2 id="update">UPDATE</h2>
<pre><code class="language-SQL">레코드 수정
UPDATE Customers SET ContactName = 'Alfred Schmidt', City= 'Frankfurt'
WHERE CustomerID = 1;

UPDATE Customers SET ContactName='Juan' WHERE Country='Mexico';
</code></pre>

<h2 id="delete">DELETE</h2>
<pre><code class="language-SQL">조건에 맞는 레코드 삭제하기
DELETE FROM Customers WHERE CustomerName='Alfreds Futterkiste';
레코드들 몽땅 삭제하기
DELETE FROM Customers
</code></pre>

<h1 id="create-drop">CREATE DROP</h1>
<pre><code class="language-SQL">CREATE DATABASE testDB;

데이터베이스, 테이블은 DROP을 통해서 삭제한다!
DROP DATABASE testDB;
</code></pre>

<h2 id="create-table">CREATE table</h2>
<p>테이블 생성</p>
<pre><code class="language-SQL">CREATE TABLE Persons (
    PersonID int,
    LastName varchar(255),
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255) DEFAULT 'Sandnes'
);
</code></pre>
<p>테이블 삭제</p>
<pre><code class="language-SQL">DROP TABLE Persons;
테이블의 데이터만 삭제
TRUNCATE TABLE Persons;
</code></pre>
<p>테이블의 컬럼을 추가, 삭제, 수정 -&gt; ALTER</p>
<pre><code class="language-SQL">ALTER TABLE Customers ADD Email varchar(255);
ALTER TABLE Customers DROP COLUMN Email;
ALTER COLUMN DateOfBirth year;
ALTER City SET DEFAULT 'Sandnes';

인덱스 생성하기
CREATE INDEX idx_pname ON Persons (LastName, FirstName);
</code></pre>
<p>SQL Constraints</p>

<table>
  <thead>
    <tr>
      <th>이름</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NOT NULL</td>
      <td>NULL값을 가지지 않는다</td>
    </tr>
    <tr>
      <td>UNIQUE</td>
      <td>이 값이 유일함을 보장</td>
    </tr>
    <tr>
      <td>PRIMARY KEY</td>
      <td>NOT NULL과 UNIQUE의 공통</td>
    </tr>
    <tr>
      <td>FOREIGN KEY</td>
      <td>TABLE간의 연관을 위한키</td>
    </tr>
    <tr>
      <td>CHECK</td>
      <td>값이 조건에 부합한지 확인</td>
    </tr>
    <tr>
      <td>DEFAULT</td>
      <td>입력값이 없을 때 기본값</td>
    </tr>
    <tr>
      <td>CREATE INDEX</td>
      <td>빠른 접근을 위한 인덱스 생성</td>
    </tr>
  </tbody>
</table>

<p>검색결과중 하나만 oR 모두 보다 크거나 작거나 비교하기.-&gt; ANY, ALL</p>
<pre><code class="language-SQL">SELECT ProductName
FROM Products WHERE ProductID &gt; ANY
  (SELECT ProductID
  FROM OrderDetails
  WHERE Quantity = 10);
</code></pre>]]></content><author><name>박정우</name></author><category term="project" /><category term="cs" /><summary type="html"><![CDATA[SQL]]></summary></entry><entry><title type="html">Preparing Project</title><link href="https://parkjoungwoo.github.io/jekyll-theme-yat/project/2022/10/01/preproject.html" rel="alternate" type="text/html" title="Preparing Project" /><published>2022-10-01T00:00:00+00:00</published><updated>2022-10-01T00:00:00+00:00</updated><id>https://parkjoungwoo.github.io/jekyll-theme-yat/project/2022/10/01/preproject</id><content type="html" xml:base="https://parkjoungwoo.github.io/jekyll-theme-yat/project/2022/10/01/preproject.html"><![CDATA[<h1 id="프로젝트-준비">프로젝트 준비</h1>
<p>최종 프로젝트를 위한 기술 스택 공부, 준비를 하려고 이번 포스트를 작성했다.</p>
<h3 id="프로젝트와-어플리케이션">프로젝트와 어플리케이션</h3>
<p>프로젝트 = 어플리케이션의 집합<br />
프로젝트에는 여러 앱이 포함될 수 있고 앱 또한 여러 프로젝트에 있을 수 있다.<br />
어플리케이션은 요청한 페이지를 보여주는 역할을 담당, 일반적으로 앱은 하나의 역할, 기능 단위로 작성한다.</p>
<h2 id="가상환경-설정">가상환경 설정</h2>
<p>프로젝트 조원들은 모두 같은 컴퓨터를 사용하지 않는다. 그러므로 비슷한 환경을 조성하기 위해 환경을 통일해주어야만 한다.</p>

<h3 id="파이썬-가상환경-생성-명령어">파이썬 가상환경 생성 명령어</h3>

<p>현재 위치에서 venv라는 폴더를 생성하고 그 아래에 가상 환경을 설정하기.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-m</span> venv &lt;venv&gt;
</code></pre></div></div>
<h3 id="가상환경-실행하기">가상환경 실행하기</h3>
<p>윈도우 상황에서 실행하므로 아래와 같은 명령어를 실행한다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>가상환경생성폴더/venv/Scripts/Activate.ps1
</code></pre></div></div>
<h3 id="가상환경-종료하기">가상환경 종료하기</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>deactivate
</code></pre></div></div>
<h3 id="가상환경-pip-목록-저장">가상환경 pip 목록 저장</h3>
<p>가상환경을 생성했다고 정리가 되는 것은 아니다. 매번 환경이 초기화 되므로 가상환경에서 사용한 패키지 목록을 저장을 해야한다.</p>

<p>또한 팀원들과의 환경설정을 공유하기 위한 목적 또한 있다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip freeze <span class="o">&gt;</span> requirements.txt
</code></pre></div></div>
<h3 id="가상환경-pip-목록대로-설치하기">가상환경 pip 목록대로 설치하기</h3>
<p>가상환경 패키지 목록을 받고 그대로 적용하고 싶다면 아래와 같은 명령어를 실행한다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pip</span> <span class="n">install</span> <span class="o">-</span><span class="n">r</span> <span class="n">requirements</span><span class="p">.</span><span class="n">txt</span>
</code></pre></div></div>

<h2 id="web이란">WEB이란</h2>
<p>기본적인 개념을 정리해보자.</p>

<p>HTTP 프로토콜이 서버와 클라이언트간의 데이터 전송을 관리
URL을 통해 클라이언트는 웹 요소에 접근
HTML 같은 웹 문서를 작성</p>

<ul>
  <li>HTTP : HTML 문서 같은 리소스들을 가져올 수 있도록 하는 프로토콜
    <ul>
      <li>웹에서 이뤄지는 모든 데이터 교환의 기초, 클라이언트-서버 프로토콜</li>
    </ul>
  </li>
  <li>요청 : 일반적으로 브라우저인 클라이언트에게 전송되는 메세지
    <blockquote>
      <p>대표적인 클라이언트 프로그램 : 브라우저</p>
    </blockquote>
  </li>
  <li>응답 : 서버에서 응답으로 전송되는 메세지
    <blockquote>
      <p>대표적인 서버 프로그램 : naver, google, github..</p>
    </blockquote>
  </li>
</ul>

<h3 id="cdn">CDN</h3>
<p>Content Delivery(Distribution) Network</p>

<ul>
  <li>컨텐츠를 효율적으로 전달하기 위해</li>
  <li>서버와 사용자 사이의 물리적 거리를 줄여 컨텐츠 로드 지연을 최소화</li>
  <li>분산된 서버로 이루어진 플랫폼</li>
</ul>

<p>장점</p>
<ul>
  <li>사용자와 가까운 서버를 통해 빠르게 전달 가능</li>
  <li>외부 서버를 활용함으로써 본인 서버의 부하가 적어진다.
    <h3 id="정적-웹페이지">정적 웹페이지</h3>
    <p>서버에서 미리 저장된 파일이 사용자에게 그대로 전달되는 웹페이지<br />
서버가 정적 웹 페이지에 대한 요청을 받을 경우 추가 작업 없이 응답.
flat page 라고도 함.</p>
    <h3 id="동적-웹페이지">동적 웹페이지</h3>
    <p>서버가 정적 웹 페이지에 대한 요청을 받을 경우 추가 작업을 통해 클라이언트에게 응답<br />
웹 페이지는 그때 그때 다르고 서버 사이드 프로그래밍 언어가 사용되고 파일을 처리, 데이터베이스와 상호 작용이 이루어진다.</p>
    <h2 id="django">Django</h2>
    <h3 id="framework">Framework</h3>
    <p>프로그래밍에서 특정 운영 체제를 위한 응용 프로그램 표준 구조를 구현하는 클래스와 라이브러리 모임<br />
재사용할 수 있는 수많은 코드를 프레임워크로 통합함.. 개발자가 새로운 애플리케이션을 위한 표준 코드를 작성하지 않아도 된다.</p>
    <h3 id="framework-architecture">Framework Architecture</h3>
    <p>MVC 디자인 패턴<br />
소프트웨어 공학에서 사용되는 디자인 패턴.<br />
사용자 인터페이스로부터 프로그램 Logic을 분리<br />
시각적인 요소를 쉽게 고칠 수 있는 어플리케이션을 만들 수 있다.<br />
<code class="language-plaintext highlighter-rouge">Django</code>는 <code class="language-plaintext highlighter-rouge">MTV Pattern</code>이라고 한다.</p>
    <h3 id="기본-구조">기본 구조</h3>
    <p>Model : 응용프로그램의 데이터 구조를 정의, 데이터베이스의 기록을 관리<br />
Template:</p>
  </li>
  <li>파일의 구조나 레이아웃을 정의\</li>
  <li>실제 내용을 보여주는데 사용</li>
</ul>

<p>View :</p>
<ul>
  <li>HTTP 요청을 수신하고 HTTP 응답을 반환\</li>
  <li>Model을 통해 요청을 충족시키는데 필요한 데이터에 접근\</li>
  <li>template에게 응답의 서식 설정을 맡김</li>
</ul>

<p>Templates :</p>
<ul>
  <li>실제 내용을 보여주는데 사용되는 파일</li>
  <li>파일의 구조나 레이아웃을 정의</li>
  <li>app폴더 안의 templates 폴더로 지정
    <h3 id="django-구조-확인">Django 구조 확인</h3>
    <p>init : Python에게 이 디렉토리를 하나의 Python 패키지로 다루도록 지시<br />
asig : 비동기 서버 게이트웨이 인터페이스, 장고가 비동기식이며 이 파일로 웹 서버와 연결 및 소통하는 것을 돕는다.<br />
settings : 어플리케이션의 모든 설정을 포함<br />
앱을 등록하기 위해서는 <code class="language-plaintext highlighter-rouge">INSTALLED_APPS</code>에 등록해야한다.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  반드시 생성을 하고 등록을 해야한다.
</code></pre></div>    </div>
  </li>
</ul>

<p>언어, 시간 설정</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LANGUAGE_CODE</span> <span class="o">=</span> <span class="s">'ko-kr'</span>
<span class="c1"># USE_I18N이 활성화되어 있어야 함
</span>
<span class="n">TIME_ZONE</span> <span class="o">=</span> <span class="s">'Asia/Seoul'</span>
<span class="c1"># 데이터베이스 연결의 시간대를 나타내는 문자열 지정
# USE_TZ = False이면 Error 발생
</span></code></pre></div></div>

<p>urls : 사이트 url과 적절한 view의 연결 지정<br />
wsgi : Web Server Gateway Interface, django 어플리케이션이 웹 서버와 소통하는 것을 돕는다<br />
manage : Django 프로젝트와 상호작용하는 CLI 유틸리티\</p>

<p>참고 : 이러한 에러가 떴을 때..</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    return _bootstrap._gcd_import(name[level:], package, level)
  File "&lt;frozen importlib._bootstrap&gt;", line 1030, in _gcd_import
  File "&lt;frozen importlib._bootstrap&gt;", line 1007, in _find_and_load
  File "&lt;frozen importlib._bootstrap&gt;", line 984, in _find_and_load_unlocked
ModuleNotFoundError: No module named 'djangorestframework'
</code></pre></div></div>
<p>includes 에서 ‘djangorestframework’가 아닌 ‘rest_framework’로 바꿔준다.<br />
프로젝트 생성하기</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>django-admin startproject 프로젝트 명
</code></pre></div></div>
<p>앱 생성하기</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python manage.py startapp 앱명
</code></pre></div></div>

<h3 id="django-template-system">Django template system</h3>
<ol>
  <li>표현과 로직을 분리한다.
    <ul>
      <li>템플릿 시스템은 표현을 제어하는 도구, 표현 관련 로직</li>
      <li>기본 목표를 넘어서는 기능은 지원하지 말아야 한다.</li>
    </ul>
  </li>
  <li>중복을 배제
    <ul>
      <li>대다수의 동적 웹사이트는 공통 디자인을 갖는다.</li>
      <li>Django 템플릿 시스템은 이러한 요소를 한곳에 쉽게 저장해, 중복 코드를 없애야 하며 이것이 템플릿 상속의 기초이다.
        <h4 id="http">HTTP</h4>
        <p>추후에 기술할 프로토콜이지만 간단하게 짚고 넘어가자 <br />
웹에서 이루어지는 모든 데이터 교환의 기초를 의미한다.<br />
주어진 리소스가 수행할 원칙을 request method로 정의한다.\</p>
      </li>
    </ul>
  </li>
  <li>GET
    <ul>
      <li>서버로부터 정보를 조회할때 사용한다.</li>
      <li>body가 아닌 Query String Parameters로 전송한다.</li>
    </ul>
  </li>
</ol>

<h3 id="django-url">Django URL</h3>
<p>URL Path Converters</p>
<blockquote>
  <p>Variable Routing : URL 주소를 변수로 사용하기</p>
</blockquote>

<p>URL의 일부를 변수로 지정, view 함수의 인자로 넘긴다.</p>
<ul>
  <li>str
    <ul>
      <li>’/’를 제외하고 모든 문자열과 매치</li>
      <li>작성하지 않을 경우 기본값</li>
    </ul>
  </li>
  <li>int
    <ul>
      <li>0 또는 양의 정수와 매치</li>
    </ul>
  </li>
  <li>slug
    <ul>
      <li>ASCII 문자 또는 숫자, 하이픈, 밑줄로 구성된 슬러그 문자열</li>
    </ul>
  </li>
  <li>uuid</li>
  <li>path</li>
</ul>

<p>일반적으로 하나의 urls.py에서 모든 view 함수를 관리하는 것은 프로젝트 유지보수에 좋지 않다.<br />
상위 디렉토리</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">django.urls</span> <span class="kn">import</span> <span class="n">path</span><span class="p">,</span> <span class="n">include</span>
<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s">'pages/'</span><span class="p">,</span> <span class="n">include</span><span class="p">(</span><span class="s">'pages.urls'</span><span class="p">)),</span>
<span class="p">]</span>
</code></pre></div></div>
<p>하위 디렉토리 상황</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># articles
</span><span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s">'index/'</span><span class="p">,</span> <span class="n">views</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">'index'</span><span class="p">),</span>
    <span class="p">...</span>
<span class="c1"># pages
</span><span class="n">urlpatterns</span><span class="o">=</span><span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s">'index/'</span><span class="p">,</span> <span class="n">views</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">'index'</span><span class="p">),</span>
    <span class="p">...</span>
</code></pre></div></div>
<p>url tag가 둘다 index로 동일하다.<br />
이러한 상황이면 서로 다른 index 이지만 같은 객체를 가르키게 된다.\</p>
<h3 id="url-namespace">URL namespace</h3>
<p>URL namespace를 통해서 서로 다른 앱에서 동일한 URL이름을 사용할 수 있다.<br />
app_name을 지정한다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">app_name</span> <span class="o">=</span> <span class="s">"pages"</span>
<span class="n">urlpatterns</span><span class="o">=</span><span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s">'index/'</span><span class="p">,</span> <span class="n">views</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">'index'</span><span class="p">)</span>    
<span class="p">...</span>
</code></pre></div></div>
<h3 id="django-model">Django Model</h3>
<p>model(스키마 작성법)</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Article</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">TextField</span><span class="p">()</span>
</code></pre></div></div>
<p>CharField -&gt; 길이 제한이 있는 문자열을 넣을때<br />
max_length는 필수 인자<br />
TextField  -&gt; 글자 수가 많을 때 사용</p>]]></content><author><name>박정우</name></author><category term="project" /><category term="web" /><summary type="html"><![CDATA[프로젝트 준비 최종 프로젝트를 위한 기술 스택 공부, 준비를 하려고 이번 포스트를 작성했다. 프로젝트와 어플리케이션 프로젝트 = 어플리케이션의 집합 프로젝트에는 여러 앱이 포함될 수 있고 앱 또한 여러 프로젝트에 있을 수 있다. 어플리케이션은 요청한 페이지를 보여주는 역할을 담당, 일반적으로 앱은 하나의 역할, 기능 단위로 작성한다. 가상환경 설정 프로젝트 조원들은 모두 같은 컴퓨터를 사용하지 않는다. 그러므로 비슷한 환경을 조성하기 위해 환경을 통일해주어야만 한다.]]></summary></entry><entry><title type="html">비지도학습</title><link href="https://parkjoungwoo.github.io/jekyll-theme-yat/machine/learning/2022/09/22/unsupervised.html" rel="alternate" type="text/html" title="비지도학습" /><published>2022-09-22T00:00:00+00:00</published><updated>2022-09-22T00:00:00+00:00</updated><id>https://parkjoungwoo.github.io/jekyll-theme-yat/machine/learning/2022/09/22/unsupervised</id><content type="html" xml:base="https://parkjoungwoo.github.io/jekyll-theme-yat/machine/learning/2022/09/22/unsupervised.html"><![CDATA[<h1 id="비지도-학습과-지도-학습">비지도 학습과 지도 학습</h1>
<p>지도 학습과 다르게 비지도 학습은 성능평가가 어렵다.</p>

<p>label이나 기준이 없기 때문</p>

<h2 id="kmeans-dbscan">Kmeans, DBSCAN</h2>
<p>대표적인 비지도학습</p>

<p><code class="language-plaintext highlighter-rouge">Kmeans</code>와 이를 보완한 <code class="language-plaintext highlighter-rouge">DBSCAN</code>이 존재한다.</p>

<h2 id="한계점">한계점</h2>

<p>iris데이터를 통해 비지도 클러스터링, 실제 값을 비교해보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span>  <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="n">sns</span>
<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_iris</span>

<span class="n">iris</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">()</span>
<span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span> <span class="c1">#센트로이드가 이동하는 횟수
</span>
<span class="n">cluster</span> <span class="o">=</span> <span class="n">kmeans</span><span class="p">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">iris</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="c1"># 군집별로 어떻게 분류했는가
</span><span class="n">plt</span><span class="p">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">sns</span><span class="p">.</span><span class="n">countplot</span><span class="p">(</span><span class="n">kmeans</span><span class="p">.</span><span class="n">labels_</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">"KMeans Clustering"</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>

<span class="c1"># 실제
</span><span class="n">plt</span><span class="p">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">sns</span><span class="p">.</span><span class="n">countplot</span><span class="p">(</span><span class="n">iris</span><span class="p">[</span><span class="s">'target'</span><span class="p">])</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">"Original"</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>
<p><img src="/assets/img/0922/count.png" alt="count" /></p>

<p>실제 분류보다 잘 못한 것을 알 수 있다.</p>

<p>이는 K-means가 거리기반으로 분류를 하기 때문이고 실제 데이터를 비교해 이유를 알 수 있다.</p>

<p><img src="/assets/img/0922/count2.jpg" alt="count2" /></p>

<p>파란색은 정확히 분리되어 거리기반으로 분류가 가능하나 나머지는 섞여 있어 거리만으로는 분류가 힘들다.</p>

<blockquote>
  <p>참고로 K-means로 분류한 결과 [0,1,2]가 실제 데이터 라벨은 아님을 알자!</p>
</blockquote>

<h2 id="dbscan">DBSCAN</h2>

<p>kmeans는 거리기반이기 때문에 기하학적인 모양의 데이터를 분류하는데 매우 치명적인 약점을 가지고 있다.</p>

<p>DBSCAN은 밀도기반으로 clustering을 진행한다.
밀도기반이기 때문에 기하학적 모양의 데이터 분포도 잘 분류한다.</p>

<ol>
  <li>몇개의 그룹으로 사용자가 나눌 필요가 없다 = K지정 필요 X</li>
</ol>

<p>그렇다면 밀도가 낮은 부분은 -&gt; -1로 나타난다.</p>

<p><img src="/assets/img/0922/DBSCAN.png" alt="DBS" /></p>

<p>학습, 예측방법은 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">DBSCAN</span>
<span class="s">'''
eps(입실론) : 반경(넓게하면...군집 수가 작아짐) / (좁게하면...군집 수가 많아진다.)
min_samples : 반경안에 몇개 이상의 데이터가 있을 때 하나의 그룹으로 인정할지 여부
'''</span>
<span class="n">dbscan</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># dbscan은 fit_predict으로 학습을 진행한다.
</span><span class="n">dbscan_data</span> <span class="o">=</span> <span class="n">dbscan</span><span class="p">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s">'sepal length (cm)'</span><span class="p">:</span> <span class="s">'petal width (cm)'</span><span class="p">])</span>
<span class="n">dbscan_data</span>
</code></pre></div></div>
<p><img src="/assets/img/0922/%EA%B5%B0%EC%A7%91%ED%99%94%20%EA%B3%84%EC%82%B0.png" alt="img" /></p>

<p>a^i <code class="language-plaintext highlighter-rouge">응집도</code>, b^i <code class="language-plaintext highlighter-rouge">분리도</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>응집도가 높고 : 데이터끼리 촘촘
분리도가 높은 : 그룸간의 거리가 먼
</code></pre></div></div>]]></content><author><name>박정우</name></author><category term="machine" /><category term="learning" /><category term="ml" /><summary type="html"><![CDATA[비지도 학습과 지도 학습 지도 학습과 다르게 비지도 학습은 성능평가가 어렵다.]]></summary></entry><entry><title type="html">의사 결정 트리</title><link href="https://parkjoungwoo.github.io/jekyll-theme-yat/machine/learning/2022/09/21/decision.html" rel="alternate" type="text/html" title="의사 결정 트리" /><published>2022-09-21T00:00:00+00:00</published><updated>2022-09-21T00:00:00+00:00</updated><id>https://parkjoungwoo.github.io/jekyll-theme-yat/machine/learning/2022/09/21/decision</id><content type="html" xml:base="https://parkjoungwoo.github.io/jekyll-theme-yat/machine/learning/2022/09/21/decision.html"><![CDATA[<h1 id="의사-결정-트리">의사 결정 트리</h1>

<p><img src="/assets/img/0921/a_1.png" alt="tree" />
원과 세모를 정확하게 구분하기</p>

<p>-&gt; 하나의 공간에 하나의 종류만 존재하도록 구분하기.</p>

<p>특이점 : 직선으로만 분류가 가능하다, 비선형은 불가능하다.</p>

<p>위 사진을 보면 하나의 영역에 섞여있는 부분, 나뉘어 있는 부분을 볼 수 있는데 얼마나 잘 나뉘어 있는가를 <code class="language-plaintext highlighter-rouge">순도</code>라고 하고 얼마나 섞여있는지는 <code class="language-plaintext highlighter-rouge">불순도</code>라고 한다.</p>

<blockquote>
  <p>불순도(=무질서도) 측정 : 엔트로피, 지니계수</p>
</blockquote>

<p>Decision Tree를 Classification으로도, Regression으로도 진행할 수 있다.</p>

<p>의사결정 트리의 목적은 엔트로피를 낮추도록 = 순도를 올리고 = 불순도를 낮추는 방향으로 진행한다. 하지만 너무 많이 결정트리가 진행되면 과적합의 부작용이 나타난다.</p>

<p>결정트리에서 사용되는 지니계수는 <code class="language-plaintext highlighter-rouge">0.0 ~ 0.5</code> 사이의 값을 가진다.</p>
<h2 id="성능을-올리기">성능을 올리기</h2>

<p>규칙을 추가하며 서브트리를 만들어 나갈수록 모델이 복잡해지고, 과적합에 빠지기 쉽다.</p>

<p>→ 트리의 크기를 사전에 제한하는 하이퍼파라미터 튜닝이 필요</p>

<blockquote>
  <p>가지를 치면서 성능을 올려야 한다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tree.feature_importances_에서
# 0 : 의사결정에서 사용되지 않은 feature
# 이런 애들을 drop하고 다시 DecisionTree로 학습 &gt; 더 빠르고 편리하고 acc이 높게 나온다.
</code></pre></div></div>]]></content><author><name>박정우</name></author><category term="machine" /><category term="learning" /><category term="ml" /><summary type="html"><![CDATA[의사 결정 트리]]></summary></entry><entry><title type="html">머신러닝 평가지표</title><link href="https://parkjoungwoo.github.io/jekyll-theme-yat/machine/learning/2022/09/20/score.html" rel="alternate" type="text/html" title="머신러닝 평가지표" /><published>2022-09-20T00:00:00+00:00</published><updated>2022-09-20T00:00:00+00:00</updated><id>https://parkjoungwoo.github.io/jekyll-theme-yat/machine/learning/2022/09/20/score</id><content type="html" xml:base="https://parkjoungwoo.github.io/jekyll-theme-yat/machine/learning/2022/09/20/score.html"><![CDATA[<h1 id="평가-지표">평가 지표</h1>

<h2 id="분류-평가-지표">분류 평가 지표</h2>

<ol>
  <li>
    <p>정확도 Accuracy</p>

    <p>(predict==y).mean()</p>
  </li>
  <li>
    <p>Confusion Matrix (Recall, Precision)</p>
  </li>
</ol>

<h2 id="회귀-평가-지표">회귀 평가 지표</h2>
<blockquote>
  <p>회귀분석의 평가는 분류보다 다소 난해할 수 있다.</p>
</blockquote>

<p>ex) 연속선상의 숫자를 예측하기/ 아파트 집값 예측과 배추값 예측</p>

<p>1억 vs 1억 5천만 / 5천원 vs 8천원 -&gt; 값의 차이는 크나 평가는 달라짐(전자가 우수한 예측)</p>

<table>
  <thead>
    <tr>
      <th>평가지표|||</th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Linear Regression||</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>R2(R-Squared)</td>
      <td>MAE</td>
      <td>MSE</td>
      <td>RMSE</td>
    </tr>
    <tr>
      <td>||||</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h2 id="variance-vs-bias">variance vs bias</h2>

<p><img src="/assets/img/0920/want.png" alt="img" /></p>

<p>위에서 설명한것과 같이 해결방법은 아래와 같다.</p>

<ol>
  <li>이상치</li>
  <li>Polynominal Feature</li>
  <li>Regulization</li>
</ol>

<h3 id="regulization-and-pipeline">Regulization and PipeLine</h3>

<p>그 중에서 정규화에 대해 설명하자면</p>

<p>전체적인 columns에 적용하고 Data의 Variance를 낮추기 위해서(OverFitting을 해결하기 위하여) Regularization을 진행한다.</p>

<table>
  <thead>
    <tr>
      <th>L1 규제</th>
      <th>L2 규제</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Lasso</td>
      <td>Ridge</td>
    </tr>
    <tr>
      <td>MSE + λ * ∑ |w|</td>
      <td>MSE + λ * ∑ w²</td>
    </tr>
  </tbody>
</table>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>규제 -&gt; w의 값을 규제한다.
Q. 규제강도(λ)를 0으로 하면?
    A. 단순 Linear Regression과 동일

Q. 규제 강도를 많이 준다?
    A. high Bias 발생, 학습을 더 많이 해야한다.

1. Lasso가 가장 낮은 MSE를 보여준다
2. alpha = 100이면 큰 에러를 보여준다. == 안정성이 낮다
3. 기업에서는 많이  사용하지 않는다.

규제 강도가 클 수록 모델이 성능이 많이 떨어진다

Lasso는 규제를 조금만 강하게 부여하면 불안정함을 보인다. 
-&gt; 현업에서는 Ridge Model을 선호한다.
-&gt; 특정한 컬럼에 극단으로 치우치는 경향을 보인다.
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Ridge</span><span class="p">,</span> <span class="n">Lasso</span>

<span class="c1"># 모델 정의
</span><span class="n">lasso_100</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="c1"># 학습
</span><span class="n">lasso_100</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="c1"># 예측
</span><span class="n">lasso_pred_100</span> <span class="o">=</span> <span class="n">lasso_100</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>

<span class="c1"># 모델 정의
</span><span class="n">ridge_100</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="c1"># 학습
</span><span class="n">ridge_100</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="c1"># 예측
</span><span class="n">ridge_pred_100</span> <span class="o">=</span> <span class="n">ridge_100</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="elastic-net">Elastic Net</h4>
<blockquote>
  <p>MSE + λ<em>L₁ + (1-λ)</em>L₂</p>
</blockquote>

<p>라쏘와 릿지의 비율을 지정해서 혼합한 규제</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 엘라스틱 비율 지정하기
# L1 위주
</span><span class="n">elsticnet_80</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">l1_ratio</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="n">elsticnet_80</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">elasticnet_pred_80</span> <span class="o">=</span> <span class="n">elsticnet_80</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>

<span class="c1"># L2위주로
</span><span class="n">elsticnet_20</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">l1_ratio</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="n">elsticnet_20</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">elasticnet_pred_20</span> <span class="o">=</span> <span class="n">elsticnet_20</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>
</code></pre></div></div>
<h4 id="pipeline">PipeLine</h4>

<p>이제 학습의 과정이</p>

<p>전처리 -&gt; fit -&gt; predict -&gt; score 인것을 알 수 있다.</p>

<p>이러한 일련의 과정을 하나의 통로로 정리한 것이 PipeLine이다</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">make_pipeline</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">make_pipeline</span><span class="p">(</span>
    <span class="n">MinMaxScaler</span><span class="p">(),</span> 
    <span class="n">ElasticNet</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">l1_ratio</span><span class="o">=</span><span class="mf">0.2</span><span class="p">),</span>
<span class="p">)</span>

<span class="n">pipeline</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">pipeline_pred</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="polynomial-features">Polynomial Features</h2>

<p>다항 회귀… 선형회귀로는 해결할 수 없는 문제를 다루기 위해 사용.</p>

<p>데이터 셋이 왼편의 그림처럼 비선형성을 부분적으로 보인다면?</p>

<p>-&gt; 단순회귀 방식을 이용해서 성능 향상을 꾀하기가 힘들다.</p>

<p>데이터 셋이 비선형적인 부분이 있다면 다항회귀를 적용해야만 성능을 올릴 수 있다.</p>

<h3 id="컬럼을-활용하기">컬럼을 활용하기</h3>

<p>타이타닉 데이터 셋에서는 sibling과 parchild 컬럼을 통해 family라는 컬럼을 창출 할 수 있다.</p>

<p>하지만 반도체 데이터를 본다면 의미를 알 수 없는 컬럼이 많기 때문에 의미를 연결해서 새로운 컬럼을 창출할 수 없다.</p>

<h3 id="다항-회귀-특성-추가">다항 회귀 특성 추가</h3>

<ol>
  <li>단순히 컬럼간의 곱으로 새로운 컬럼을 만든다</li>
  <li>단순히 컬럼의 제곱으로 새로운 컬럼을 만든다 …이렇게 컬럼 수 늘림</li>
</ol>

<blockquote>
  <p>연산 방식에서 더하기와 빼기는 왜 하지 않을까?</p>
</blockquote>

<p>키 180cm + 시력 1.7 -&gt; 의미가 없음</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>결론

컬럼간의 연산, 병합 같은 일련의 행위를 통해서 "종합적인 정보를 획득"할 수 있는 장점이 있다.
</code></pre></div></div>

<p>다항회귀 파이프라인 예시코드</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">poly_pipeline</span> <span class="o">=</span> <span class="n">make_pipeline</span><span class="p">(</span>
    <span class="n">StandardScaler</span><span class="p">(),</span>
    <span class="n">PolynomialFeatures</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">include_bias</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span>
    <span class="n">ElasticNet</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">l1_ratio</span><span class="o">=</span><span class="mf">0.2</span><span class="p">),</span>
<span class="p">)</span>
</code></pre></div></div>]]></content><author><name>박정우</name></author><category term="machine" /><category term="learning" /><category term="ml" /><summary type="html"><![CDATA[평가 지표]]></summary></entry></feed>